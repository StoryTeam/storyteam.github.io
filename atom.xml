<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StoryTeam</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://StoryTeam.cn/"/>
  <updated>2017-01-08T05:36:19.000Z</updated>
  <id>http://StoryTeam.cn/</id>
  
  <author>
    <name>StoryTeam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ios本地视频那些坑</title>
    <link href="http://StoryTeam.cn/2016/12/30/2016-12-30-ios%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://StoryTeam.cn/2016/12/30/2016-12-30-ios本地视频那些坑/</id>
    <published>2016-12-30T10:57:00.000Z</published>
    <updated>2017-01-08T05:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、没有音轨，小心crash"><a href="#一、没有音轨，小心crash" class="headerlink" title="一、没有音轨，小心crash"></a>一、没有音轨，小心crash</h3><p>1.在没有音轨的视频中，通过<code>NSArray *audioMediaList = [asset tracksWithMediaType:AVMediaTypeAudio]</code>；得到的数组是空的，再用<code>[audioMediaList objectAtIndex:0]</code>取音轨对象，就访问越界，导致crash，大家多注意。</p>
<a id="more"></a>
<pre><code>2.另外创建AVMutableCompositionTrack对象后一定要向其中insert内容，否则导出视频时，检测到有空的track对象，会导出失败。
</code></pre><p><img src="http://ojfz9611q.bkt.clouddn.com/8.png" alt=""></p>
<h3 id="二、视频的诡异方向"><a href="#二、视频的诡异方向" class="headerlink" title="二、视频的诡异方向"></a>二、视频的诡异方向</h3><p>日记中的视频都要求竖着播放，于是在代码中判断“if (videoTrack.naturalSize.width > videoTrack.naturalSize.height)”就做90度旋转，让宽高的值交换，使视频竖着播，但是，发现有些视频原本就是竖向的，但width大于height，导致我们旋转后变成了横屏。方向信息，这样的视频很少，但确实存在，于是我们在旋转完，宽高信息与视频方向统一后，再来检查“if (videoTrack.naturalSize.width > videoTrack.naturalSize.height)”，如果还是宽大于高，再旋转一次，就好啦。</p>
<p>这是当时出事的视频，用不同播放器，方向也不一样，神奇的视频</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/9.png" alt=""><br><img src="http://ojfz9611q.bkt.clouddn.com/10.png" alt=""></p>
<h3 id="三、旋转矩阵中的平易变量"><a href="#三、旋转矩阵中的平易变量" class="headerlink" title="三、旋转矩阵中的平易变量"></a>三、旋转矩阵中的平易变量</h3><pre><code>关于视频旋转，ios默认的视频矩阵如下图，tx，ty的值如果异常，就会导致矩阵变换之后，视频部分或全部在视口之外。
</code></pre><p><img src="http://ojfz9611q.bkt.clouddn.com/11.png" alt=""></p>
<p>如下图就是一个ty异常的bug，安卓拍摄的视频矩阵信息中ty为0，ios使用时检查ty为0时，手动赋值才可以。<br>关于视频矩阵，有兴趣可以看：<a href="http://www.jianshu.com/p/6c09d138b31d" target="_blank" rel="external">http://www.jianshu.com/p/6c09d138b31d</a></p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/12.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、没有音轨，小心crash&quot;&gt;&lt;a href=&quot;#一、没有音轨，小心crash&quot; class=&quot;headerlink&quot; title=&quot;一、没有音轨，小心crash&quot;&gt;&lt;/a&gt;一、没有音轨，小心crash&lt;/h3&gt;&lt;p&gt;1.在没有音轨的视频中，通过&lt;code&gt;NSArray *audioMediaList = [asset tracksWithMediaType:AVMediaTypeAudio]&lt;/code&gt;；得到的数组是空的，再用&lt;code&gt;[audioMediaList objectAtIndex:0]&lt;/code&gt;取音轨对象，就访问越界，导致crash，大家多注意。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式（二）</title>
    <link href="http://StoryTeam.cn/2016/12/28/2016-12-28-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://StoryTeam.cn/2016/12/28/2016-12-28-设计模式（二）/</id>
    <published>2016-12-28T07:43:00.000Z</published>
    <updated>2017-01-08T05:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h3><p>面向对象设计原则为设计可复用、可扩展、可维护、灵活的软件系统提供了指导性原则，本文分别从设计原则的定义、通俗理解、案例分析三个维度详细讲解了七条设计原则，旨在加深大家对设计原则的理解，提升开发设计能力，早日远离烂代码。</p>
<a id="more"></a>
<h3 id="设计原则意义"><a href="#设计原则意义" class="headerlink" title="设计原则意义"></a>设计原则意义</h3><p>面相对象设计的终极目标是希望软件系统具有可复用性、可维护性、可拓展等特性，同时这几个特性也是我们检测软件系统是不是设计得合理的衡量标准。面向对象的设计原则为软件系统的设计提供了指导性的原则。掌握、运用这些规则不仅能设计出优秀的软件系统同时也能提升我们自身的开发设计能力。</p>
<p>罗伯特·C·马丁在21世纪早期引入的记忆术首字母缩略字提出了SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转），指代了面向对象编程和面向对象设计的五个基本原则。随着程序设计的不断发展，增加了合成复用原则、迪米特法则二个基本原则，接下来详细讲解这七条基本原则：</p>
<ol>
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>里氏代换原则</li>
<li>依赖倒转原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法原则</li>
</ol>
<h3 id="七条设计原则"><a href="#七条设计原则" class="headerlink" title="七条设计原则"></a>七条设计原则</h3><h4 id="单一职责原则-Single-Responsibility-Principle—SRP"><a href="#单一职责原则-Single-Responsibility-Principle—SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle—SRP)"></a>单一职责原则(Single Responsibility Principle—SRP)</h4><p>定义：就一个类而言，应该仅有一个引起它变化的原因<br>通俗的理解就是：一个类如果承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，它被复用的可能性就很小。因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。<br>单一职责原则是实现高内聚、低耦合的指导方针。</p>
<h5 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h5><p>开发人员针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图所示初始设计方案：<br>￼<br><img src="http://7xotrj.com1.z0.glb.clouddn.com/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A31.jpg" alt=""></p>
<p>在上图中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。<br>在上图中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p>
<ol>
<li>DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</li>
<li>CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</li>
<li>CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。<br>现使用单一职责原则对其进行重构: </li>
</ol>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A32.jpg" alt="">￼</p>
<h4 id="开放封闭原则-Open-Closed-Principle—OCP"><a href="#开放封闭原则-Open-Closed-Principle—OCP" class="headerlink" title="开放封闭原则(Open-Closed Principle—OCP)"></a>开放封闭原则(Open-Closed Principle—OCP)</h4><p>定义：是说软件实体（类、模块、函数等等）应该可以扩展，但是不可以修改</p>
<p>开放-封闭原则是面向对象设计的核心所在，遵守这个原则可以收获巨大好处，也就是可维护、可扩展、可复用、灵活性好。</p>
<p>注意事项:开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，同时要避免刻意的进行抽象，总之，拒绝不成熟的抽象和抽象本身一样重要。</p>
<h5 id="案例讲解-1"><a href="#案例讲解-1" class="headerlink" title="案例讲解"></a>案例讲解</h5><p>CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/oc1.jpg" alt=""></p>
<p>在ChartDisplay类的display()方法中存在如下代码片段：<br>    if (type.equals(“pie”))<br>    {<br>    PieChart chart = new PieChart();<br>    chart.display();<br>    }<br>    else if (type.equals(“bar”))<br>    {<br>    BarChart chart = new BarChart();<br>    chart.display();<br>    }<br>在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。<br>在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p>
<ol>
<li>增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</li>
<li>ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。<br>重构后结构如图所示：</li>
</ol>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/oc2.jpg" alt=""></p>
<h4 id="里氏代换原则-Liskov-Substitution-Principle—LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle—LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle—LSP)"></a>里氏代换原则(Liskov Substitution Principle—LSP)</h4><p>定义：子类型必须能够替换掉它们的父类型</p>
<p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。通俗的理解就是，一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。</p>
<p>里氏代换原则是实现开闭原则的重要方式之一。</p>
<p>注意事项：</p>
<ol>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>
<li>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。<h5 id="案例讲解-2"><a href="#案例讲解-2" class="headerlink" title="案例讲解"></a>案例讲解</h5></li>
</ol>
<p>在CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/ls1.jpg" alt=""></p>
<p>在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。</p>
<p>为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。</p>
<p>在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。<br>重构后的结构如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/ls2.jpg" alt=""></p>
<h4 id="依赖倒转原则-Dependence-Inversion-Principle—DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle—DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle—DIP)"></a>依赖倒转原则(Dependence Inversion Principle—DIP)</h4><p>定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p>
<h4 id="接口隔离原则-Interface-Segregation-Principle—ISP"><a href="#接口隔离原则-Interface-Segregation-Principle—ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle—ISP)"></a>接口隔离原则(Interface Segregation Principle—ISP)</h4><p>定义：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>
<ol>
<li>当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，此时，这个原则可以叫做“角色隔离原则”。</li>
<li>如果把“接口”理解成狭义的特定语言的接口，在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。<h5 id="案例讲解-3"><a href="#案例讲解-3" class="headerlink" title="案例讲解"></a>案例讲解</h5></li>
</ol>
<p>开发人员针对某CRM系统的客户数据显示模块设计了如图所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。初始设计方案结构图:</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/is1.jpg" alt=""></p>
<p>在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。<br>由于在接口CustomerDataDisplay中定义了太多方法，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。<br>将该接口按照接口隔离原则和单一职责原则进行重构，重构后的结构如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/is2.jpg" alt=""></p>
<h4 id="合成复用原则-Composite-Reuse-Principle—CRP"><a href="#合成复用原则-Composite-Reuse-Principle—CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle—CRP)"></a>合成复用原则(Composite Reuse Principle—CRP)</h4><p>定义：尽量使用合成/聚合，尽量不要使用类继承</p>
<p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变。</p>
<p>简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承</p>
<h5 id="案例讲解-4"><a href="#案例讲解-4" class="headerlink" title="案例讲解"></a>案例讲解</h5><p> 在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/cr1.jpg" alt=""></p>
<p>随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。<br>根据合成复用原则，我们在实现复用时应该多用关联，少用继承,重构后的结构如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/cr2.jpg" alt=""></p>
<p>在上图中，CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。</p>
<h4 id="迪米特法则-Law-of-Demeter—LoD"><a href="#迪米特法则-Law-of-Demeter—LoD" class="headerlink" title="迪米特法则(Law of Demeter—LoD)"></a>迪米特法则(Law of Demeter—LoD)</h4><p>定义：一个软件实体应当尽可能少地与其他实体发生相互作用</p>
<p>通俗理解：如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>
<h5 id="案例讲解-5"><a href="#案例讲解-5" class="headerlink" title="案例讲解"></a>案例讲解</h5><p> CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图所示结构：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/LOD1.jpg" alt=""></p>
<p>在上图中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p>
<p>通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如图所示：</p>
<p><img src="http://7xotrj.com1.z0.glb.clouddn.com/LOD2.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h3&gt;&lt;p&gt;面向对象设计原则为设计可复用、可扩展、可维护、灵活的软件系统提供了指导性原则，本文分别从设计原则的定义、通俗理解、案例分析三个维度详细讲解了七条设计原则，旨在加深大家对设计原则的理解，提升开发设计能力，早日远离烂代码。&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="http://StoryTeam.cn/categories/%E5%85%B6%E5%AE%83/"/>
    
    
  </entry>
  
  <entry>
    <title>最简单的拍摄原型研究</title>
    <link href="http://StoryTeam.cn/2016/11/30/2016-11-30-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%8B%8D%E6%91%84%E5%8E%9F%E5%9E%8B%E7%A0%94%E7%A9%B6/"/>
    <id>http://StoryTeam.cn/2016/11/30/2016-11-30-最简单的拍摄原型研究/</id>
    <published>2016-11-30T15:51:00.000Z</published>
    <updated>2017-01-08T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在关注拍摄卡顿的问题，由于拍摄相关逻辑非常多，直接研究会有比较大的困难，于是尝试搭建一个最简单的原型。一个是为了理解相关的机制，另一方面，也可以看看最少逻辑的情况下，卡顿会到怎样的程度。<br>这里分为两个部分，操作摄像头，还有渲染出捕获的图像。（暂且只研究拍摄，存储与压缩不涉及）。</p>
<a id="more"></a>
<h4 id="1-摄像头"><a href="#1-摄像头" class="headerlink" title="1. 摄像头"></a>1. 摄像头</h4><p>翻了iOS编程的所有层级，我以为会找到底层的C风格的接口，没有找到。</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/20.jpg" alt="(img)"></p>
<p>如图，CoreVideo和CoreMedia其实并没有提供直接操作摄像头的接口，仅仅是一些基本的数据结构和支撑性的公共类，更像是一个公共库。曾经找到一个比较底层的接口，ICCameraDevice，但这个接口仅在MacOS上才提供。也翻了一些网上的资料，确认在iOS系统上，最底层的接口，就是AV Fondation所提供的接口。</p>
<p>摄像头的编程模型，就是一个生产者与消费者的模型，摄像头捕捉图像，输出到一个队列，预览窗口从队列里面获取图像，展示在窗口上。</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/22.jpg" alt="(img)"></p>
<p>仅从图像数据获取，主要有5个主要的对象</p>
<ol>
<li>AVCaptureDevice     设备，用于控制设备的相关特性，比如闪光灯，对焦方式，自动曝光等。</li>
<li>AVCaptureDeviceInput 设备的输入对象，这个类几乎没有什么方法，是专门用于和Session配合的类。</li>
<li>AVCaptureSession Session是一个总的协调者，输入的输入和输出就通过Session来联系。启动与停止也是由Session来控制的。</li>
<li>AVCaptureConnection    连接，连接Input和Output，可以设置摄像头方向，最大帧率等，在最简单的模式下，这个并不是必须的，包含在CaptureSession里面了。</li>
<li>AVCaptureVideoDataOutput 数据的输出对象，可以拿到原始的图像数据。<br>使用这些类并不复杂，需要按照一定的流程，首先，我们需要获得一个device</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">AVCaptureDevice</span>*)getBackCamera</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span>* devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span>* device <span class="keyword">in</span> devices)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (device.position == <span class="built_in">AVCaptureDevicePositionBack</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> device;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码不算特别严谨，这个方法返回一个后置摄像头。<br>然后用它来初始化一个deviceInput对象</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><div class="line"><span class="variable">_deviceInput</span> = [AVCaptureDeviceInput deviceInputWithDevice:<span class="variable">_device</span> error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>然后再初始化session对象</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><div class="line"><span class="variable">_captureSession</span> = [[AVCaptureSession alloc] init];</div><div class="line"><span class="keyword">if</span> ([<span class="variable">_captureSession</span> canAddInput:<span class="variable">_deviceInput</span>])</div><div class="line"> &#123;</div><div class="line">	 [<span class="variable">_captureSession</span> addInput:<span class="variable">_deviceInput</span>];</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>然后就可以创建output对象了</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)initVideoOutput</div><div class="line">&#123;</div><div class="line">    _videoOutput = [[AVCaptureVideoDataOutput alloc] init];</div><div class="line">    [_videoOutput <span class="string">setSampleBufferDelegate:</span>(self) <span class="string">queue:</span>dispatch_queue_create(<span class="string">"sample buffer queue"</span>, DISPATCH_QUEUE_SERIAL)];</div><div class="line">    <span class="keyword">if</span> ([_captureSession <span class="string">canAddOutput:</span>_videoOutput])</div><div class="line">    &#123;</div><div class="line">        [_captureSession <span class="string">addOutput:</span>_videoOutput];</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    AVCaptureConnection* connection = [_videoOutput <span class="string">connectionWithMediaType:</span>AVMediaTypeVideo];</div><div class="line">    [connection <span class="string">setVideoOrientation:</span>AVCaptureVideoOrientationPortrait];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里需要一个Serial Queue，因为每帧必须保证按顺序处理。<br>还有通过Connection对象设置图像的方向，是因为默认情况下，竖着拍你会发现图像旋转了90度，这里设置以后才能看见正常的图像。<br>通过output可以设置AVCaptureVideoDataOutputSampleBufferDelegate，这个delegate可以把原始的图像数据给出来。有两个方法:</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><div class="line">-  <span class="params">(void)</span>captureOutput:<span class="params">(AVCaptureOutput *)</span>captureOutput didOutputSampleBuffer:<span class="params">(CMSampleBufferRef)</span>sampleBuffer fromConnection:<span class="params">(AVCaptureConnection *)</span>connection</div><div class="line">-  <span class="params">(void)</span>captureOutput:<span class="params">(AVCaptureOutput *)</span>captureOutput didDropSampleBuffer:<span class="params">(CMSampleBufferRef)</span>sampleBuffer fromConnection:<span class="params">(AVCaptureConnection *)</span>connection</div></pre></td></tr></table></figure>
<p>一个是帧数据回调，一个是丢帧回调。<br>CMSampleBufferRef就是原始的图像数据，接下来，就是考虑如何把图像展示出来。只要速度够快（按30帧算，每帧处理不能超过33ms）。对于上面的回调来说，如果一个回调的处理时间超过了33ms，就可能导致画面的延迟，如果时间再长，或者几次都比较长，累积下来就会导致丢帧。<br>之前卡顿有个结论就是CPU高会导致丢帧，而根本原因是CPU繁忙导致每帧的处理时间变长，累积以后导致丢帧。如果让这里的处理时间足够短，比如在不使用挂件的情况下，尽可能降低这里的逻辑执行，那么即使第一次启动可能也可以保持帧率的流畅。<br>AVFondation提供了一个好用的封装类，AVCaptureVideoPreviewLayer，使用起来非常非常的简单。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">- (void)<span class="keyword">displayUsePreviewLayer</span></div><div class="line">&#123;</div><div class="line">    _previewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession]<span class="comment">;</span></div><div class="line">    _previewLayer.frame = self.view.frame<span class="comment">;</span></div><div class="line">    [self.view.layer <span class="keyword">addSublayer:_previewLayer];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用Session初始化一下，直接添加一个layer就搞定。而且还可以自动纠正图像的方向。<br>在Demo的代码里面，</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><div class="line">//[self displayUsePreviewLayer]<span class="comment">;</span></div><div class="line">[self displayUseGLView]<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>使用上面的方法，就可以直接使用PreviewLayer了。然后我使用这种方法试了下，在第一次启动马上点拍摄，使用这个简单的类，不仅启动很快（低于500ms），而且预览也非常流畅。当然，这个没有任何逻辑处理，算是很极致的情况，但是也说明，如果做极致的优化，卡顿的情况是可以得到很大缓解的。而且启动速度也有比较大的提升空间。就这个事情，跟基础侧也聊了下，他们认为这个最简单的情况并不能表明我们的优化空间很大，现在的拍摄逻辑太复杂，优化是很困难的。<br>我打算，在我们也理解和熟悉的基础上，推动基础侧一起进行优化。</p>
<h4 id="2-渲染"><a href="#2-渲染" class="headerlink" title="2. 渲染"></a>2. 渲染</h4><p>渲染这块，首先还是找最底层的开发接口。确认最底层的就是OpenGL ES了。OpenGL是一个宽广的体系。OpenGL ES是OpenGL的嵌入式版本（Embedded Systems），最新版本是3.2。OpenGL的硬件加速原理跟MMX这类指令类似，就是可以通过专门的硬件一次处理更多的数据和做更复杂的操作。<br>       图形图像处理有一些固定的处理，比如计算Alpha混合，放大缩小，变换色彩空间等，抽象出来就是对象与对象之上的操作，这个操作，在OpenGL里面称为渲染管线，或者理解为通过硬件实现的一个处理流程。这个流程在OpenGL ES 1.X里面是固定的，要加速只能选择固定的处理模式。而在OpenGL ES 2.X里面，渲染管线是可编程的，有专门的脚本，GLSL。<br>       关于这块我理解也不深，我现在需要解决的是，如何把SampleBuffer渲染出来。查了一些资料，使用了最简单的方法。<br>       系统提供了GLKView，用于封装OpenGL ES的一些操作，我尝试通过最原始的方式，继承了一个UIView。首先需要修改Layer的Class，这样才能用于OpenGL ES的渲染。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">+ (Class)layerClass</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">CAEAGLLayer</span> <span class="keyword">class</span>];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="keyword">void</span>)setupLayer</div><div class="line">&#123;</div><div class="line">    _EAGLLayer = (<span class="built_in">CAEAGLLayer</span>*)<span class="keyword">self</span>.layer;</div><div class="line">    _EAGLLayer.opaque = <span class="literal">YES</span>;</div><div class="line">    _EAGLLayer.drawableProperties = @&#123;</div><div class="line">                                      kEAGLDrawablePropertyRetainedBacking: @NO,</div><div class="line">                                      kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8</div><div class="line">                                      &#125;;</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是layer需要换成CAEAGLLayer，然后设置为不透明（性能），还有每次擦除原图，还有一个颜色的格式。<br>主要的两个对象，EAGLContext，还有CIContext。EAGLContext是OpenGL ES的上下文，CIContext是Core Image里面图像的上下文。</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><div class="line">- (void)initEAGLContext</div><div class="line">&#123;</div><div class="line">    EAGLRenderingAPI glAPI = kEAGLRenderingAPIOpenGLES2;</div><div class="line">    <span class="variable">_glContext</span> = [[EAGLContext alloc] initWithAPI:glAPI];</div><div class="line">    <span class="keyword">if</span> (<span class="variable">_glContext</span> == <span class="literal">nil</span>)</div><div class="line">    &#123;</div><div class="line">        NSLog(@<span class="string">"GLES2 init failed!"</span>);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    [EAGLContext setCurrentContext:<span class="variable">_glContext</span>];</div><div class="line">   </div><div class="line">    <span class="variable">_pxContext</span> = [CIContext contextWithEAGLContext:<span class="variable">_glContext</span>];</div><div class="line">    [<span class="variable">_pxContext</span> retain];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EAGLRenderingAPI用于指定API的版本，也就是前面说的1.X和2.X，一般使用2.X。然后再用glContext初始化CIContext。<br>中间涉及到RenderBuffer和FrameBuffer的代码，涉及到OpenGL的渲染体系，这里我也不是特别熟，就不展开讲了。<br>关键的方法</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">drawSampleBuffer:</span>(CMSampleBufferRef) sampleBuffer</div><div class="line">&#123;</div><div class="line">    CVPixelBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);</div><div class="line">    CIImage* image = [CIImage <span class="string">imageWithCVPixelBuffer:</span>imageBuffer];</div><div class="line">    [_pxContext <span class="string">drawImage:</span>image <span class="string">inRect:</span>self.frame <span class="string">fromRect:</span>image.extent];</div><div class="line">    [_glContext <span class="string">presentRenderbuffer:</span>GL_RENDERBUFFER];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码非常简单，从SampleBuffer里获得PixelBuffer，然后转换为CIImage，给CIContext进行绘制，然后通过GLContext渲染出来。</p>
<p>这个最简单的拍摄预览原型就搭建好了。这里所提到的代码在Demo的LightCamera文件夹下。<br>通过这个Demo，一个是了解了拍摄相关的技术点和大致流程，另外也了解到在现有的CPU负载情况下，帧率能优化到什么程度。下一步，就是分析完整的每帧处理流程，看能否有压缩的空间。后面计划和基础侧一起，希望能把卡顿优化到满意的程度。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在关注拍摄卡顿的问题，由于拍摄相关逻辑非常多，直接研究会有比较大的困难，于是尝试搭建一个最简单的原型。一个是为了理解相关的机制，另一方面，也可以看看最少逻辑的情况下，卡顿会到怎样的程度。&lt;br&gt;这里分为两个部分，操作摄像头，还有渲染出捕获的图像。（暂且只研究拍摄，存储与压缩不涉及）。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理讨论总结</title>
    <link href="http://StoryTeam.cn/2016/11/30/2016-11-30-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E8%AE%A8%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://StoryTeam.cn/2016/11/30/2016-11-30-内存管理讨论总结/</id>
    <published>2016-11-30T13:03:00.000Z</published>
    <updated>2017-01-08T06:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-内存管理的分类"><a href="#1-内存管理的分类" class="headerlink" title="1 内存管理的分类"></a>1 内存管理的分类</h4><p>　　GC（Garbage Collection，垃圾回收）是一种自动的内存管理机制：将不再使用或者没有任何指针指向的内存空间收集起来，以便再次利用。相较于人肉管理内存，GC更为简单、安全，也更容易被理解。<br>GC的方法主要可以分为两大类：基于引用计数（Reference Counting）的垃圾回收器、基于跟踪处理（Tracing）的垃圾回收器。</p>
<a id="more"></a>
<h5 id="1-1-基于引用计数的垃圾回收器"><a href="#1-1-基于引用计数的垃圾回收器" class="headerlink" title="1.1 基于引用计数的垃圾回收器"></a>1.1 基于引用计数的垃圾回收器</h5><p>  引用计数是将资源（对象/内存/磁盘空间等等）的被引用次数保存起来，当被引用次数变为0时就将其释放的方法。<br>  a.优点：<br>  ·简单。<br>  ·快速：由于计数的增减与对象的使用是紧密结合的，与其他垃圾回收算法相比，该方法不会造成程序暂停，对程序需要不被长时间打断的实时环境比较有利。<br>  b.缺点：<br>  ·循环引用：下文3.1循环引用中有详细介绍。</p>
<h5 id="1-2-基于跟踪处理的垃圾回收器"><a href="#1-2-基于跟踪处理的垃圾回收器" class="headerlink" title="1.2 基于跟踪处理的垃圾回收器"></a>1.2 基于跟踪处理的垃圾回收器</h5><p>相比于引用计数，跟踪处理的垃圾回收机制被更为广泛的应用。其基本方法是由离散数学中的图论产生跟踪对象的关系图，然后进行垃圾回收。<br>使用跟踪方式的垃圾回收算法主要有以下几种：</p>
<p>1、标记-清除（Mark-Sweep）<br>该方法使用根搜索算法：程序把所有的引用关系看作一张图，从根节点开始，遍历整张图，标记所有被引用的节点。遍历完成后，所有未标记的节点会被当做无用节点，将在清扫阶段被释放。<br>  a.优点：<br>·高效：该算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。<br>b.缺点：<br>·内存碎片化：正是因为该算法直接回收不存活的对象，在高效率的同时会造成大量的内存碎片。</p>
<p>2、标记-整理（Mark-Compact）<br>该算法标记的方法与标记-清除法一致，只是在遍历所有被引用节点并进行标记之后，会将所有的标记节点往左端空闲空间移动，并更新对应的指针。这就解决了内存碎片的问题。<br>a.优点：<br>·解决了内存碎片化问题。<br>b.缺点：<br>·成本高：该算法在标记-清除算法的基础上，又进行了对象的移动，因此成本更高。<br>·句柄开销：需要使用句柄和句柄表。</p>
<p>3、标记-拷贝（Mark-Copy）<br>该算法将堆空间分为两个部分：对象面、空闲面。系统从对象面的堆空间里面分配内存，当对象面分配满时，从根节点扫描所有被引用对象，将其复制到空闲面并保证所有被引用对象所占用的内存是连续的。如此，对象面的堆空间里剩下的全是垃圾。而空闲面里的对象都是紧密排列的。接下来转换对象面和空闲面的角色，继续从新的对象面中开始分配。<br>a.优点：<br>·解决了内存碎片化问题。<br>·避免了标记-整理法的句柄开销。<br>b.缺点：<br>·在对象面与空闲区域面的切换过程中，程序暂停执行。</p>
<h4 id="2-OC的内存管理"><a href="#2-OC的内存管理" class="headerlink" title="2 OC的内存管理"></a>2 OC的内存管理</h4><p>  OC内存管理有三种方式，按由旧到新顺序排列分别：自动垃圾收集（Automatic Garbage Collection）、手动引用计数器（Manual Reference Counting）和自动释放池（Autorelease Pool）、自动引用计数器（Automatic Reference Counting）。</p>
<h5 id="2-1-AGC（自动垃圾收集）"><a href="#2-1-AGC（自动垃圾收集）" class="headerlink" title="2.1 AGC（自动垃圾收集）"></a>2.1 AGC（自动垃圾收集）</h5><p>  AGC是一种自动垃圾收集的内存管理形式，本质也是引用计数，但并不在对象计数为0时立即将其释放，而是等到某一特定时刻统一释放回收内存。由于回收时机的不确定性，且需要一定时间处理回收，此方法较容易产生卡顿。<br>  iOS运行环境中从来不支持AGC，在OS X较早版本中才使用AGC，V10.8及之后版本也已将其弃用此方法，转而推荐使用ARC进行替代。</p>
<h5 id="2-2-MRC（手动引用计数）和Autorelease-Pool（自动释放池）"><a href="#2-2-MRC（手动引用计数）和Autorelease-Pool（自动释放池）" class="headerlink" title="2.2 MRC（手动引用计数）和Autorelease Pool（自动释放池）"></a>2.2 MRC（手动引用计数）和Autorelease Pool（自动释放池）</h5><p>1、MRC<br>MRC是通过人为控制来增减引用计数的方式。将一个对象指针赋值给另一个对象指针如下：<br>    Person p1 = [Person new];<br>    Person p2 = [Person new];<br>// 在p2失去对对象的控制权前需要先release<br>    [p2 release];<br>// 再进行赋值操作<br>    p2 = p1;</p>
<p>2、Autorelease Pool<br>Autorelease即自动释放对象，不需要手动释放。在Autorelease Pool内的对象在创建时只需调用autorelease方法，编译器将在最后完成在该池子内对象的release方法。<br>Autorelease Pool的创建方式为：<br>    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]  init];<br>    [pool release];<br>其语法糖形式为：<br>    @autoreleasepool{<br>    }</p>
<h5 id="2-3-ARC（自动引用计数）"><a href="#2-3-ARC（自动引用计数）" class="headerlink" title="2.3 ARC（自动引用计数）"></a>2.3 ARC（自动引用计数）</h5><p>  ARC是由编译器来自动完成对象引用计数器控制的方式。将一个对象指针赋值给另一个对象指针，只需要直接进行赋值即可：<br>    Person p1 = [Person new];<br>    Person p2 = [Person new];<br>// 直接进行赋值操作<br>    p2 = p1;</p>
<h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3 内存泄漏"></a>3 内存泄漏</h3><p>内存泄漏是指应用程序分配某段内存后，发生某些错误，导致在释放该段内存之前就失去了对该段内存的控制，未能释放已经不再使用的内存，从而造成了内存的浪费。</p>
<h5 id="3-1-循环引用"><a href="#3-1-循环引用" class="headerlink" title="3.1 循环引用"></a>3.1 循环引用</h5><p>1、产生原因<br>对于两个类A、B，在A包含B且B包含A的情况下，产生循环：<br>// Book1类的声明和实现<br>    @interface Book1:NSObject<br>    @property(nonatomic,retain) Book2 *_book2;<br>    (void)dealloc；<br>    @end<br>    @implementation Book1</p>
<p>// 重载dealloc方法销毁对象<br>    (void)dealloc<br>    {<br>        [_book2 release];<br>        [super dealloc];<br>    }<br>    @end</p>
<p>// Book2类的声明和实现<br>    @interface Book2:NSObject<br>    @property(nonatomic,retain) Book1 *_book1;<br>    (void)dealloc；<br>    @end<br>    @implementation Book2</p>
<p>// 重载dealloc方法销毁对象<br>    (void)dealloc<br>    {<br>        [_book1 release];<br>        [super dealloc];<br>    }<br>    @end</p>
<p>// 主函数测试<br>    void main()<br>    {<br>        Book1 <em>b1=[[Book1 alloc] init];<br>        Book2 </em>b2=[[Book2 alloc] init];<br>        b1.book2 = b2;<br>        b2.book1 = b1;<br>        [b1 release];<br>        [b2 release];<br>    }<br>  当执行<code>[b1 release]</code>后，b1释放对Book1的控制权，此时Book1的引用计数器RC=2-1=1。<br>  当执行<code>[b2 release]</code>后，b2释放对Book2的控制权，此时Book2的引用计数器RC=2-1=1。<br>此时由于仍有指针指向Book1和Book2，系统并不会调用dealloc函数，因此Book1和Book2并不会毁销，就造成了内存泄露。</p>
<p>2、解决方法<br>要解决循环引用造成的内存泄漏，MRC中需要在Book1和Book2的@property属性声明中一端使用retain，一端使用assign。ARC中需要一端使用strong，一端使用weak。</p>
<h5 id="3-2-返回值释放"><a href="#3-2-返回值释放" class="headerlink" title="3.2 返回值释放"></a>3.2 返回值释放</h5><p>1、产生原因<br>MRC中，在返回对象的方法里，如果将新创建的对象作为返回值，由于在返回该对象之前并不能释放该对象，将会造成内存泄漏。ARC中无此问题。</p>
<p>2、解决方法：<br>使用自动释放池释放对象，通过自动释放池来延迟该对象的释放：<br>    (Person <em>)getNewPerson<br>    {<br>        Person p</em> = [[[Person alloc] init] autorelease];<br>        …<br>        return p;<br>    }<br>或者<br>    {<br>        Person p* = [[Person alloc] init] ;<br>        …<br>        return [p autorelease];<br>    }。</p>
<h5 id="3-3-setter重写"><a href="#3-3-setter重写" class="headerlink" title="3.3 setter重写"></a>3.3 setter重写</h5><p>1、产生原因<br>MRC中，若重写setter方法，将对象直接赋给另一对象，将无法调用自动合成方法，旧值没有release，有可能造成内存泄露。</p>
<p>2、解决方法<br>手动retain新值，release旧值：<br>    (void)setBook:(Book *)book<br>    {<br>        if (_book != book)<br>    {<br>          // 使之前对象的RC-1<br>              [_book release];<br>              // 当前引用的RC+1<br>              _book = [book retain];<br>        }<br>    }</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h4><p>为避免MRC/ARC中的内存泄漏，应注意如下几个方面：<br>·注意野指针问题，避免其引起的crash。<br>·保证所有类均有走dealloc被成功析构。<br>·每写完一个类查看内存增长情况。<br>·尽量使用显式destroy自己控制对象释放。<br>·提高意识，牢记宗旨——谁创建，谁释放。<br>·借助工具检查内存泄漏情况，如：<br>a.编译选项中，启用Zombie Objects，可在访问/释放已被释放的对象时报警，避免野指针。<br>b.使用Analyze/Instrument等扫描内存泄漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-内存管理的分类&quot;&gt;&lt;a href=&quot;#1-内存管理的分类&quot; class=&quot;headerlink&quot; title=&quot;1 内存管理的分类&quot;&gt;&lt;/a&gt;1 内存管理的分类&lt;/h4&gt;&lt;p&gt;　　GC（Garbage Collection，垃圾回收）是一种自动的内存管理机制：将不再使用或者没有任何指针指向的内存空间收集起来，以便再次利用。相较于人肉管理内存，GC更为简单、安全，也更容易被理解。&lt;br&gt;GC的方法主要可以分为两大类：基于引用计数（Reference Counting）的垃圾回收器、基于跟踪处理（Tracing）的垃圾回收器。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>气泡抖动动画实现</title>
    <link href="http://StoryTeam.cn/2016/11/30/2016-11-30-%E6%B0%94%E6%B3%A1%E6%8A%96%E5%8A%A8%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://StoryTeam.cn/2016/11/30/2016-11-30-气泡抖动动画实现/</id>
    <published>2016-11-30T10:24:00.000Z</published>
    <updated>2017-01-08T06:20:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Bezier曲线绘制圆形"><a href="#1-Bezier曲线绘制圆形" class="headerlink" title="1.Bezier曲线绘制圆形"></a>1.Bezier曲线绘制圆形</h4><p>有的时候我们需要对圆形的某个部分进行形变处理，但是修改transform属性常常修改的是整个圆形的样式，无法满足我们的需求。所以我们需要用多段贝赛尔曲线来实现圆形的绘制，这样我们可以通过修改其中某一段曲线样式，从而实现针对圆形某个局部的变形。</p>
<a id="more"></a>
<p> <img src="http://ojfz9611q.bkt.clouddn.com/17.jpg" alt=""></p>
<p>如上图，我们可以通过AB, BC, CD, DA四段贝塞尔曲线来合成一个圆形，这样我们就可以对圆的局部进行动画操作了。</p>
<p>那么问题来了，如何通过Bezier曲线来拟合1/4的圆呢？<br>Bezier三阶曲线方程是：<code>P(t) = A*(1 - t)3 + C1*3(1 - t)2t + C2*3(1 - t)t2 + B*t3, t = 0 ... 1</code>。当A到 C1的距离和B到 C2的距离是3.6时，贝塞尔所拟合的曲线最接近1/4圆，具体的推导过程可以参考这篇博客<a href="http://blog.csdn.net/nibiewuxuanze/article/details/4810305" target="_blank" rel="external">http://blog.csdn.net/nibiewuxuanze/article/details/4810305</a> </p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/18.gif" alt="">        </p>
<p>所以对于四个关键点和8个控制点的代码如下：</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/13.jpg" alt=""></p>
<p>将四段贝塞尔曲线拼接起来，我们就可以得到圆形了。</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/14.jpg" alt=""></p>
<h4 id="2-使用阻尼振动来模拟气泡的抖动过程"><a href="#2-使用阻尼振动来模拟气泡的抖动过程" class="headerlink" title="2.使用阻尼振动来模拟气泡的抖动过程"></a>2.使用阻尼振动来模拟气泡的抖动过程</h4><p>阻尼振动是指任何<a href="https://zh.wikipedia.org/wiki/%E6%8C%AF%E5%8A%A8" target="_blank" rel="external">振动</a>系统在振动中，由于外界作用（如流体<a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E5%8A%9B" target="_blank" rel="external">阻力</a>、<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E6%93%A6%E5%8A%9B" target="_blank" rel="external">摩擦力</a>等）和/或系统本身固有的原因引起的<a href="https://zh.wikipedia.org/wiki/%E6%8C%AF%E5%B9%85" target="_blank" rel="external">振动幅度</a>逐渐下降，在实际振动中，由于摩擦力总是存在的，所以振动系统最初所获得的能量，在振动过程中因阻力不断对系统做负功，使得系统的能量不断减少，振动的强度逐渐减弱，振幅也就越来越小，以至于最后的停止振动，像这样的因系统的力学能，由于摩擦及转化成内能逐渐减少，振幅随时间而减弱振动，称为阻尼振动</p>
<p>所以使用阻尼振动来模拟一些动画效果可以使得动画看起来更加流畅，逼真。<br>阻尼振动的具体实现就不详细列举了，有兴趣的同学可以看一下：<a href="https://zh.wikipedia.org/wiki/%E9%98%BB%E5%B0%BC" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%98%BB%E5%B0%BC</a> </p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/15.jpg" alt=""></p>
<p>我们把X轴的位置当作上图点A的横坐标，通过阻尼运动来模拟A点在中心点的来回摆动，就可以得到一个气泡的摆动动画。（为来让动画看起来更明显，刻意延长了动画时间，增加了摆动幅度，所以可能动画看起来有点变扭）。</p>
<p> <img src="http://ojfz9611q.bkt.clouddn.com/16.jpg" alt=""></p>
<p>最终得到的效果图如下：</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/19.gif" alt=""></p>
<p>结：贝塞尔曲线和阻尼振动在动画的设计和实现上很好用，如果能灵活使用，我们可以实现出很多很好的动画效果</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Bezier曲线绘制圆形&quot;&gt;&lt;a href=&quot;#1-Bezier曲线绘制圆形&quot; class=&quot;headerlink&quot; title=&quot;1.Bezier曲线绘制圆形&quot;&gt;&lt;/a&gt;1.Bezier曲线绘制圆形&lt;/h4&gt;&lt;p&gt;有的时候我们需要对圆形的某个部分进行形变处理，但是修改transform属性常常修改的是整个圆形的样式，无法满足我们的需求。所以我们需要用多段贝赛尔曲线来实现圆形的绘制，这样我们可以通过修改其中某一段曲线样式，从而实现针对圆形某个局部的变形。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>踩坑与收获</title>
    <link href="http://StoryTeam.cn/2016/11/23/2016-11-23-%E8%B8%A9%E5%9D%91%E4%B8%8E%E6%94%B6%E8%8E%B7%20copy/"/>
    <id>http://StoryTeam.cn/2016/11/23/2016-11-23-踩坑与收获 copy/</id>
    <published>2016-11-23T07:55:00.000Z</published>
    <updated>2017-01-08T04:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、先说说踩坑"><a href="#一、先说说踩坑" class="headerlink" title="一、先说说踩坑"></a>一、先说说踩坑</h3><p>在做一个透明动画时，view的透明度从0到1在到0，所以view的初始透明度设为0，同时这个view要接受点击事件，于是在view上面加了手势事件，这时问题就出现了。UIVIEW在透明度为0时是不会接收手势事件的，写了个demo验证，确实是这样，透明度为0和隐藏view是一样的，所以手势没有用。</p>
<a id="more"></a>
<p><img src="http://ojfz9611q.bkt.clouddn.com/image001.png" alt=""></p>
<h3 id="二、收获"><a href="#二、收获" class="headerlink" title="二、收获"></a>二、收获</h3><h5 id="1-如何判断野指针"><a href="#1-如何判断野指针" class="headerlink" title="1.如何判断野指针"></a>1.如何判断野指针</h5><p><code>&lt;malloc/malloc.h&gt;</code>中包含内存分配的一些函数和结构体，其中<code>malloc_zone_from_ptr</code>函数可以获取这个指针是否已经分配空间，如果是NULL的话，说明指针并没有指向任何可用区域，那么就不因该使用它去调用任何方法即野指针。使用<code>if(malloc_zone_from_ptr(object))</code>即可判断野指针。</p>
<p>下面是<code>malloc_zone_from_ptr</code>的源码，在内存分配时（alloc，new, copy），系统会把分配的内存记录在一个叫<code>malloc_zones[]</code>的数组中，<code>malloc_zone_from_ptr</code>做的就是遍历这个数组，查看指针指向的地址是否在分配的内存中，如果有就返回大小，没有就返回NULL。</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/image003.png" alt=""><br><img src="http://ojfz9611q.bkt.clouddn.com/image005.png" alt=""></p>
<p>源码地址：<a href="https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c" target="_blank" rel="external">https://opensource.apple.com/source/libmalloc/libmalloc-53.1.1/src/malloc.c</a></p>
<h5 id="2-屏幕打印log"><a href="#2-屏幕打印log" class="headerlink" title="2.屏幕打印log"></a>2.屏幕打印log</h5><p>偶然看到一个好用的屏幕打印组建，实现很轻，才100多行代码，效果也不错，可以用来把数据上报打印出来，手q已经有了类似功能</p>
<p><img src="http://ojfz9611q.bkt.clouddn.com/image007.png" alt=""></p>
<p>git地址：<a href="https://github.com/DaiYue/HAMLogOutputWindow" target="_blank" rel="external">https://github.com/DaiYue/HAMLogOutputWindow</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、先说说踩坑&quot;&gt;&lt;a href=&quot;#一、先说说踩坑&quot; class=&quot;headerlink&quot; title=&quot;一、先说说踩坑&quot;&gt;&lt;/a&gt;一、先说说踩坑&lt;/h3&gt;&lt;p&gt;在做一个透明动画时，view的透明度从0到1在到0，所以view的初始透明度设为0，同时这个view要接受点击事件，于是在view上面加了手势事件，这时问题就出现了。UIVIEW在透明度为0时是不会接收手势事件的，写了个demo验证，确实是这样，透明度为0和隐藏view是一样的，所以手势没有用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Instrument之time profiler</title>
    <link href="http://StoryTeam.cn/2014/07/05/2014-07-05-instrumentzhi-time-profiler%20copy/"/>
    <id>http://StoryTeam.cn/2014/07/05/2014-07-05-instrumentzhi-time-profiler copy/</id>
    <published>2014-07-05T10:31:36.000Z</published>
    <updated>2017-01-08T04:56:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直断断续续的学习instrument，没有整理相关的经验与资料，久而久之就慢慢忘记了，所以今天就静下心来整理一下time profiler相关的资料。</p>
<a id="more"></a>
<h2 id="如何启动"><a href="#如何启动" class="headerlink" title="如何启动"></a>如何启动</h2><blockquote>
<p>已知晓者可略过直接进入\&lt;界面介绍></p>
</blockquote>
<p>time profiler的启动分为真机抓包、代码profile这两种方式，如果需要更接近真实数据建议使用低配置一点的机器使用真机抓包，这样误差会更少些。</p>
<h4 id="1、真机抓取"><a href="#1、真机抓取" class="headerlink" title="1、真机抓取"></a>1、真机抓取</h4><p>真机抓包的前提是手机要有证书，并且能够通过Instrument run起APP，否则是抓不到任何数据包的。如何确实是run不了真机的APP，那可以略过这节直接进入代码层面的profile。</p>
<p>右击XCode图标，如下选择：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_1.png" alt="Instrument的启动"></p>
<p>打开之后双击Time Profiler即可打开：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_2.png" alt="打开Time Profiler"></p>
<p>打开之后选择你需要连接的APP即可抓包：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_3.png" alt="抓包"></p>
<h4 id="2、代码profile"><a href="#2、代码profile" class="headerlink" title="2、代码profile"></a>2、代码profile</h4><p>这个方法抓包的到数据不一定真实，因为是使用模拟器来抓包，如果只是想要个大概的数据，这种方法也是一种不错的选择。</p>
<p>启动XCode，选择菜单Product -> Profile：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_4.png" alt="Instrument的启动"></p>
<p>Instrument启动之后会弹出一个如上的选择界面，双击Time Profiler即可。</p>
<h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><blockquote>
<p>如果您对time profiler的主界面了如指掌，可直接进入\&lt;使用技巧></p>
</blockquote>
<p>下图是一般使用到的视图都打开的界面，如跟您的不一样请不要吃惊，可通过设置开启一样的界面：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_5.png" alt="主界面"></p>
<p>下面我们就对主界面的几个重点区域分别介绍：</p>
<h4 id="1、设置关注时间段"><a href="#1、设置关注时间段" class="headerlink" title="1、设置关注时间段"></a>1、设置关注时间段</h4><p>通过设置开始、设置结束、清除设置来查看您所关心的范围的数据：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_6.png" alt="主界面"></p>
<h4 id="2、运行记录"><a href="#2、运行记录" class="headerlink" title="2、运行记录"></a>2、运行记录</h4><p>可查看多次运行的数据，进行可视化对比：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_7.png" alt="运行记录"></p>
<h4 id="3、视图开关"><a href="#3、视图开关" class="headerlink" title="3、视图开关"></a>3、视图开关</h4><p>分别为三个视图的开关，全部选上可达到主界面截图效果。</p>
<h4 id="4、Liabrary"><a href="#4、Liabrary" class="headerlink" title="4、Liabrary"></a>4、Liabrary</h4><p>用于添加其它数据抓取工具，需要添加直接将liabrary内的图标拖到左边的Instruments列中。</p>
<h4 id="5、搜索条"><a href="#5、搜索条" class="headerlink" title="5、搜索条"></a>5、搜索条</h4><p>如果您需要快速查找具体的类或函数，可在些输入类名或者函数名，会有意想不到的效果。</p>
<h4 id="6、数据可视化面板"><a href="#6、数据可视化面板" class="headerlink" title="6、数据可视化面板"></a>6、数据可视化面板</h4><p>可在此设置您需要关注的范围，以便将不相干的内容过滤掉。</p>
<h4 id="7、相关内容扩展详情面板"><a href="#7、相关内容扩展详情面板" class="headerlink" title="7、相关内容扩展详情面板"></a>7、相关内容扩展详情面板</h4><h4 id="8、选项面板"><a href="#8、选项面板" class="headerlink" title="8、选项面板"></a>8、选项面板</h4><p>这个会在使用技巧中提到如果使用。</p>
<h4 id="9、详情面板"><a href="#9、详情面板" class="headerlink" title="9、详情面板"></a>9、详情面板</h4><p>在time profiler下主要是看Call Tree和Sample List这两种视图：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_8.png" alt="视图介绍"></p>
<p><strong>调用树（Call Tree）</strong></p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_9.png" alt="视图介绍"></p>
<ul>
<li>Running Time：函数运行的时间，这个时间是累积时间</li>
<li>Self：在栈顶次数</li>
<li>Symbol Name：被调用函数的符号信息</li>
</ul>
<p>从详情面板Call Tree与相关内容扩展详情面板对应的关系图：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_10.png" alt="详情面板对应关系图"></p>
<p>详情面板更多的信息选项（由于本人还未对此做深入研究，所以还不懂它们的作用）：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_11.png" alt="详情面板对应关系图"></p>
<p><strong>样本列表（Sample List）</strong></p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_12.png" alt="视图介绍"></p>
<ul>
<li>Timestamp：采样的开始时间</li>
<li>Dep：堆栈深度</li>
<li>CPU：线程运行在那一个CPU上</li>
<li>Process：进程名称</li>
<li>Thread：所在的线程名称</li>
<li>Hot Frame：采样中调用最多的函数</li>
<li>Responsible Library：调用该函数的库</li>
<li>Responsible Caller：调用该函数的函数</li>
</ul>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><blockquote>
<p>技巧收集点比较乱，都是些在使用中发现的。如您有更好的请麻烦也告知我，大家一起进步成长熟练。</p>
</blockquote>
<h4 id="1、快速展开-折叠调用栈"><a href="#1、快速展开-折叠调用栈" class="headerlink" title="1、快速展开/折叠调用栈"></a>1、快速展开/折叠调用栈</h4><p>如您不想一级一级的展开调用栈，可如下操作一次全部展开或者折叠。</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_13.png" alt="视图介绍"></p>
<h4 id="2、比较两次run的差异"><a href="#2、比较两次run的差异" class="headerlink" title="2、比较两次run的差异"></a>2、比较两次run的差异</h4><p>如您想将多次run的结果进行差异对比，可如下操作：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_14.png" alt="run差异比较"></p>
<h4 id="3、过滤"><a href="#3、过滤" class="headerlink" title="3、过滤"></a>3、过滤</h4><p>3.1、按着option键在主界面6中通过拖动鼠标来选择需要过滤的时间段。</p>
<p>3.2、Command+F查找过滤的函数名或者类名。</p>
<p>3.3、Call Tree过滤，在主界面8中直接选择：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_15.png" alt="Call Tree过滤"></p>
<ul>
<li>Separate byt Thread（建议选择）：通过线程分类来查看那些纯种占用CPU最多。</li>
<li>Invert Call Tree（不建议选择）：调用树倒返过来，将习惯性的从根向下一级一级的显示，如选上就会返过来从最底层调用向一级一级的显示。如果想要查看那个方法调用为最深时使用会更方便些。</li>
<li>Hide Missing Symbols（建议选择）：隐藏丢失的符号，比如应用或者系统的dSYM文件找不到的话，在详情面板上是看不到方法名的，只能看一些读不明的十六进值，所以对我们来说是没有意义的，去掉了会使阅读更清楚些。</li>
<li>Hide System Libraries（建议选择）：选上它只会展示与应用有关的符号信息，一般情况下我们只关心自己写的代码所需的耗时，而不关心系统库的CPU耗时。</li>
<li>Show Obj-C Only（建议选择）：选上它只会展示Objective-C methods，C和C++的函数是不会展示的，不过如果您的应用有写C和C++的代码时也想要查看这些代码的耗时，那就建议不要选择上。</li>
<li>Flatten Recursion（一般不选）：选上它会将调用栈里递归函数作为一个入口。</li>
<li>Top Functions（一般不选）：选上它会将最耗时的函数降序排列，而这种耗时是累加的，比如A调用了B，那么A的耗时数是会包含B的耗时数。</li>
</ul>
<p>3.4、Call Tree Constraints过滤</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_18.png" alt="Call Tree Constraints过滤"></p>
<ul>
<li>Count：设置调用的次数。</li>
<li>Time (ms)：设置耗时范围。</li>
</ul>
<h4 id="4、关联代码"><a href="#4、关联代码" class="headerlink" title="4、关联代码"></a>4、关联代码</h4><p>例如我想要查看setBackgroundColo这个函数的代码处，可以直接双击它就会跳转到关联的代码段。</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_16.png" alt="关联代码"></p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_17.png" alt="关联代码"></p>
<p>跳转到的代码段可看到提示这里有100%的耗时。</p>
<h4 id="5、数据录制模式"><a href="#5、数据录制模式" class="headerlink" title="5、数据录制模式"></a>5、数据录制模式</h4><p>如上面介绍的都是使用实时模式，其实还有另一种模式是延时模式，它们的区别在乎：</p>
<ul>
<li>实时模式：这是一个默认模式，因为它是实时的所以Instrument和应用是使用同一块CPU，自然也会对CPU是一种耗时，所以抓得到的数据是会有所影响，但官方苹果表示这个影响不会很大。</li>
<li>延时模式：这个模式会更小化对数据影响，当您在录制时这种模式会禁掉Instrument的实时动态刷新效果，直接到录制完成才会将数据显示出来。</li>
</ul>
<p>模式切换如下：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_19.png" alt="模式切换"></p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_20.png" alt="模式切换"></p>
<p>当选择了延时模式抓数据时，您是看不到任何Instrument给你提供的信息，只能等你抓包结束之后才会显示出来：</p>
<p><img src="http://cnkyle.qiniudn.com/Instrument%E4%B9%8Btime%20profiler20140703_21.png" alt="模式切换"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直断断续续的学习instrument，没有整理相关的经验与资料，久而久之就慢慢忘记了，所以今天就静下心来整理一下time profiler相关的资料。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://StoryTeam.cn/categories/iOS/"/>
    
    
  </entry>
  
</feed>
